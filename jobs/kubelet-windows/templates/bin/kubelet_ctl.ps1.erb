trap { $host.SetShouldExit(1) }

$env:PATH+=";C:\var\vcap\packages\docker\docker\;"

<% iaas = nil %>
<% if_p('cloud-provider') do |cloud_provider| %>
  <% iaas = cloud_provider %>
  $cloud_provider="<%= cloud_provider %>"
<% end %>

<% if_link('cloud-provider') do |cloud_provider| %>
    $cloud_config="/var/vcap/jobs/kubelet-windows/config/cloud-provider.ini"
    <% cloud_provider.if_p('cloud-provider.gce.service_key') do |service_key| %>
      $env:GOOGLE_APPLICATION_CREDENTIALS="/var/vcap/jobs/kubelet-windows/config/service_key.json"
    <% end %>
    <% cloud_provider.if_p('cloud-provider.aws.access_key_id') do |access_key_id| %>
      $env:AWS_ACCESS_KEY_ID="<%= access_key_id %>"
    <% end %>
    <% cloud_provider.if_p('cloud-provider.aws.secret_access_key') do |secret_access_key| %>
      $env:AWS_SECRET_ACCESS_KEY="<%= secret_access_key %>"
    <% end %>
<% end %>

<%
  labels = ["spec.ip=#{spec.ip}","bosh.id=#{spec.id}","bosh.zone=#{spec.az}"]
  if iaas=="vsphere"
    labels << "failure-domain.beta.kubernetes.io/zone=#{spec.az}"
  end

  if_p('k8s-args') do |args|
    custom_labels = args.fetch('node-labels', "").split(",")
    labels = custom_labels + labels
    args.delete('node-labels')
  end

  labels = labels.join(',')
%>

<% if_p('http_proxy') do |http_proxy| %>
$env:HTTP_PROXY=<%= http_proxy %>
<% end %>
<% if_p('https_proxy') do |https_proxy| %>
$env:HTTPS_PROXY=<%= https_proxy %>
<% end %>
<% if_p('no_proxy') do |no_proxy| %>
$env:NO_PROXY=<%= no_proxy %>
<% end %>

# variables for cert generation
$CONFIG_DIR = "C:\var\vcap\jobs\kubelet-windows\config"
$PKS_API_HOST = "<%= link('pks_api_shared').p('pks.fqdn') %>"
$PKS_API_URL = "https://${PKS_API_HOST}:9021/internal/certificates/kubelet"
$NODE_IP = "<%= spec.ip %>"
$BOSH_ID = "<%= spec.id %>"
$DEPOLYMENT_NAME = "<%= spec.deployment %>"

$CLUSTER_UUID = ($DEPOLYMENT_NAME -Split "_")[1]
$KUBELET_CERT_PATH = "${CONFIG_DIR}\kubelet.pem"
$KUBELET_KEY_PATH = "${CONFIG_DIR}\kubelet-key.pem"
$POST_DATA = @"
{
  \"cluster_uuid\": \"${CLUSTER_UUID}\",
  \"bosh_id\": \"${BOSH_ID}\",
  \"ip\": \"${NODE_IP}\"
}
"@

function wait_for_pks_master_dns_resolve(){
    for ($retry = 0; $retry -lt 5; $retry++){
    if (Test-Connection -Count 3 "${PKS_API_HOST}") {break}
    echo "pks_master_aliases dns not resolving ,wait for 5 seconds to retry ${retry}..."
    sleep 5
    }
    echo "pks-api resolved"
}

function do_kubelet_certificate_sign($exists){
    if ($exists -eq "true"){
        $api_url="${PKS_API_URL}/generate"
    }
    else{
        $api_url="${PKS_API_URL}/generate_if_not_present"
    }

    $api_call="curl.exe -X POST -d '${POST_DATA}' -H ""Content-Type:application/json"" --cacert C:\var\vcap\jobs\kubelet-windows\certificates\pks.crt --ssl-no-revoke ""${api_url}"""
    $retry_count = 0
    $api_output = Invoke-Expression ${api_call}
    for ($retry = 0; $retry -lt 3; $retry++){
        if ([string]::IsNullOrEmpty($api_output) -or $api_output -match "error") {
            sleep 5
            $api_output = Invoke-Expression ${api_call}
            echo "reconnecting to pks-api "
        }else{
            break
        }
    }
   if ([string]::IsNullOrEmpty($api_output) -or $api_output -match "error"){
       echo "Failed to get kubelet certificate."
       exit 1
   } else{
       $certificate_pem = ($api_output | ConvertFrom-Json )."value"."certificate"
       $private_key_pem = ($api_output | ConvertFrom-Json )."value"."private_key"
       ${certificate_pem} | Out-File -Encoding ASCII -FilePath "${KUBELET_CERT_PATH}"
       ${private_key_pem} | Out-File -Encoding ASCII -FilePath "${KUBELET_KEY_PATH}"
       echo "successfully prepared kubelet certificate."
   }
}

function delete_stale_drained_node {
  $nodes=(/var/vcap/packages/kubernetes-windows/bin/kubectl --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain get nodes -o json | ConvertFrom-Json).Items
  $nodes | ForEach-Object {
    if ($_.metadata.labels."bosh.id" -eq "<= spec.id %>") {
      if (($_.status.conditions | ? type -eq "Ready").status -ne "True") {
        /var/vcap/packages/kubernetes-windows/bin/kubectl --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain delete node "${node_name}" --ignore-not-found
      }
    }
  }
}

function get_hostname_override {
  if ($cloud_provider -in "gce", "azure") {
    return ""
  } else {
    return "<%= spec.ip %>"
  }
}

function start_kubelet {
  <%-
    include_config = false
    if !iaas.nil? and iaas != "vsphere"
      if_link('cloud-provider') do
        include_config = true
      end
    end
  -%>
  mkdir -force C:\tmp # workaround for conformance tests

  /var/vcap/packages/kubernetes-windows/bin/kubelet `
  <%-
    if_p('k8s-args') do |args|
      args.each do |flag, value|
        valueString = ""

        if value.nil?
          # Do nothing to supports args-less flags (--example)
        elsif value.is_a? Array
          valueString = "=#{value.join(",")}"
        elsif value.is_a? Hash
          valueString = "=#{value.map { |k,v| "#{k}=#{v}" }.join(",")}"
        else
          valueString = "=#{value}"
        end
  -%>
    <%= "--#{flag}#{valueString}" %> `
  <%-
      end
    end
  -%>
  <%-
    if_p('file-arguments') do |args|
      args.each do |flag, content|
      fileName = "/var/vcap/jobs/kubelet-window/config/"+flag
  -%>
    <%= "--#{flag}=#{fileName}" %> `
  <%-
      end
    end
  -%>
    <% if include_config -%>--cloud-config=${cloud_config}<% end %> `
    <% if !iaas.nil? -%>--cloud-provider=${cloud_provider}<% end %> `
    --hostname-override=$(get_hostname_override) `
    --node-labels=<%= labels %> `
    --config="/var/vcap/jobs/kubelet-windows/config/kubeletconfig.yml" `
    --tls-cipher-suites=<%= link('kube-apiserver').p('tls-cipher-suites') %>

}

function check_for_networking {
  $cniInitFile='<%= p('cni_init_file') %>'

  if (-not ([System.IO.File]::Exists($cniInitFile)))
  {
    throw "$cniInitFile does not exist, waiting for CNI initialization"
  }
}

function set_acls {
  $ar = New-Object System.Security.AccessControl.FileSystemAccessRule("BUILTIN\Users", "ReadAndExecute,CreateFiles,AppendData", "ContainerInherit, ObjectInherit", "None", "Allow")
  $acl = Get-Acl C:\var
  $acl.SetAccessRule($ar)
  Set-Acl C:\var $acl
}

function main {

  wait_for_pks_master_dns_resolve

  if (!(Test-Path $KUBELET_CERT_PATH)){
      echo "Start to sign kubelet certificate..."
      do_kubelet_certificate_sign "true"
  } else{
      $ip_in_cert = ((certutil.exe -dump ${KUBELET_CERT_PATH}| Select-String -pattern "IP Address") -Split "=")[1]
      if ($NODE_IP -eq $ip_in_cert){
          do_kubelet_certificate_sign "false"
      } else {
          do_kubelet_certificate_sign "true"
      }
  }
  delete_stale_drained_node
  check_for_networking
  set_acls
  start_kubelet
}

main
